% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Solvers.R
\name{QuantileQp}
\alias{QuantileQp}
\title{Fast Regression with Quantile (and absolute) Penalty - Quadratic programming solution}
\usage{
QuantileQp(
  Z,
  Y,
  lambda,
  H,
  alpha = 1/2,
  w = NULL,
  vrs = "C",
  toler_solve = 1e-35
)
}
\arguments{
\item{Z}{Data matrix of dimension \code{\eqn{m_{\star}}}-times-\code{p}, where \code{\eqn{m_{\star}}} is
the total number of observations, \code{p} is the dimension of \code{theta}.}

\item{Y}{Vector of total responses of length \code{\eqn{m_{\star}}}=\eqn{\sum_{i=1}^{\code{n}}(\code{m_i})}.}

\item{lambda}{Tuning parameter, a non-negative real number.}

\item{H}{Penalty matrix of size \code{p}-times-\code{p} that
is used inside the quadratic term for penalizing estimated parameters.}

\item{alpha}{The order of the quantile if \code{type="quantile"}. By default
taken to be \code{alpha=1/2}, which gives the absolute loss 
(\code{type="absolute"}).}

\item{w}{Vector of length \code{m_star} of weights attached to the elements of 
\code{Y}. If \code{w=NULL} (default), a constant vector with values 
\code{1/n} is used.}

\item{vrs}{Version of the algorithm to be used. The program is prepared in
two versions: i) \code{vrs="C"} calls the \code{C++} version of the 
algorithm, programmed within the \code{RCppArmadillo} framework for
manipulating matrices. This is typically the fastest version, especially if p >> n. 
ii) \code{vrs="R"} calls the \code{R} version. The two versions may 
give slightly different results due to the different tolerances used for the solution
of the quadratic problem.}

\item{toler_solve}{Unused at the moment}
}
\value{
A list composed of:
\itemize{
 \item{"theta_hat"}{ A numerical matrix of size \code{p}-times-\code{1} of 
 estimated regression coefficients.}
 \item{"resids"}{ A numerical vecotor of length \code{\eqn{m_{\star}}} containing the final
 set of residuals in the fit of \code{Y} on \code{Z}.}
 \item{"hat_values"}{ Diagonal terms of the (penalized) hat matrix of
 the form \code{Z*solve(t(Z)*Z + \eqn{m_{\star}}*lambda*H)*t(Z)}.}
 \item{"fitted"}{ Fitted values in the model. A vector of length \code{\eqn{m_{\star}}} 
 correponding to the fits of \code{Y}.}
}
}
\description{
A Quantile regression estimator with a specified penalty matrix
in a linear functional regression model. The solution corresponds to the 
result of function \link{IRLS} with \code{type="Quantile"} or \code{type="Absolute"} if \code{"alpha"} is 0.5.
}
\details{
This function is equivalent with 
\link{IRLS} when used with the loss \code{type="Absolute"} if \code{alpha} = 1/2 and  \code{type="Quantile"} otherwise,
 but faster and more stable as it does not perform the iterative algorithm. Note that this function
is faster than \link{IRLS} only if the number of predictors p is larger than the number of functional observations \eqn{m_{\star}}.
On the contrary, if \eqn{m_{\star}} > p, \link{IRLS} is faster, even though less accurate. When p > \eqn{m_{\star}}, the  \code{vrs="C"} version is
faster than the  \code{vrs="R"} one.
}
\examples{
n = 50      # sample size
p = 10      # dimension of predictors
Z = matrix(rnorm(n*p),ncol=p) # design matrix \eqn{m_{\star}} x p 
Y = Z[,1]   # response vector
lambda = 1  # tuning parameter for penalization
H = diag(p) # penalty matrix

res_C = QuantileQp(Z, Y, lambda, H, vrs="C")
res_R = QuantileQp(Z, Y, lambda, H, vrs="R")
# Check the maximum absolute difference between the results
max(abs(res_C$theta_hat-res_R$theta_hat))
# Visualize the difference between the results
plot(res_C$theta_hat ~ res_R$theta_hat)

# Compare the output with function IRLS
res_IRLS = IRLS(Z, Y, lambda, H, type="quantile")
max(abs(res_C$theta_hat-res_IRLS$theta_hat))

}
\seealso{
\link{IRLS} for an iterative version of this
function.
}
