% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Solvers.R
\name{HuberQp}
\alias{HuberQp}
\title{Fast Regression with Huber Penalty - Quadratic programming solution}
\usage{
HuberQp(Z, Y, lambda, H, w = NULL, vrs = "C", toler_solve = 1e-35)
}
\arguments{
\item{Z}{Data matrix of dimension \code{n}-times-\code{p}, where \code{n} is
the number of observations, \code{p} is the dimension.}

\item{Y}{Vector of responses of length \code{n}.}

\item{lambda}{Tuning parameter, a non-negative real number.}

\item{H}{Penalty matrix of size \code{p}-times-\code{p} that
is used inside the quadratic term for penalizing estimated parameters.}

\item{w}{Vector of length \code{n} of weights attached to the elements of 
\code{Y}. If \code{w=NULL} (default), a constant vector with values 
\code{1/n} is used.}

\item{vrs}{Version of the algorhitm to be used. The program is prepared in
two versions: i) \code{vrs="C"} calls the \code{C++} version of the 
algorithm, programmed within the \code{RCppArmadillo} framework for
manipulating matrices. This is typically the fastest version, especially if p >> n. 
ii) \code{vrs="R"} calls the \code{R} version. The two versions may 
give slightly different results due to the different tolerances used for the solution
of the qudratic problem.}

\item{toler_solve}{Unused at the moment}
}
\value{
A list composed of:
\itemize{
 \item{"theta_hat"}{ A numerical matrix of size \code{p}-times-\code{1} of 
 estimated regression coefficients.}
 \item{"resids"}{ A numerical vecotor of length \code{n} containing the final
 set of residuals in the fit of \code{Y} on \code{Z}.}
 \item{"hat_values"}{ Diagonal terms of the (penalized) hat matrix of
 the form \code{Z*solve(t(Z)*Z + n*lambda*H)*t(Z)}.}
 \item{"fitted"}{ Fitted values in the model. A vector of length \code{n} 
 correponding to the fits of \code{Y}.}
}
}
\description{
A Huber regression estimator with a specified penalty matrix
in a linear functional regression model. The solution corresponds to the 
result of function \link{IRLS} with \code{type="Huber"}.
}
\details{
This function is equivalent with 
\link{IRLS} when used with the square loss \code{type="Huber"}, but faster 
and more stable as it does not perform the iterative algorithm. Note that this function
is faster than \link{IRLS} only if the number of predictors p is larger than the number of functional observations n.
On the contrary, if n > p, \link{IRLS} is faster, even though less accurate. When p > n, the  \code{vrs="C"} version is
faster than the  \code{vrs="R"} one.
}
\examples{
n = 50      # sample size
p = 10      # dimension of predictors
Z = matrix(rnorm(n*p),ncol=p) # design matrix
Y = Z[,1]   # response vector
lambda = 1  # tuning parameter for penalization
H = diag(p) # penalty matrix

res_C = HuberQp(Z, Y, lambda, H, vrs="C")
res_R = HuberQp(Z, Y, lambda, H, vrs="R")
# Check the maximum absolute difference between the results
max(abs(res_C$theta_hat-res_R$theta_hat))
# Visualize the difference between the results
plot(res_C$theta_hat ~ res_R$theta_hat)

# Compare the output with function IRLS
res_IRLS = IRLS(Z, Y, lambda, H, type="Huber")
max(abs(res_C$theta_hat-res_IRLS$theta_hat))

}
\seealso{
\link{IRLS} for an iterative version of this
function.
}
