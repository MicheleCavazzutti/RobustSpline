% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Solvers.R
\name{evaluate_objective}
\alias{evaluate_objective}
\title{Objective function}
\usage{
evaluate_objective(theta, Y, Z, H_star, type, alpha = 1/2, tuning = 1.345)
}
\arguments{
\item{theta}{Minimizer of the loss, obtained through IRLS or others. Vector of dimension p.}

\item{Y}{Minimizer of the loss, obtained through IRLS, ridge, or quadratic solvers. Dimension \eqn{m_{\star}}.}

\item{Z}{Z matrix of the problem. Dimension \eqn{m_{\star}} x p.}

\item{H_star}{lambda x H matrix, drives the quadratic penalization of the model. Dimension p x p.}

\item{type}{The type of the loss function used in the minimization problem.
Accepted are \code{type="absolute"} for the absolute loss \code{rho(t)=|t|/2};
\code{type="quantile"} for the (asymmetric) quantile loss 
\code{rho(t)=t(alpha-I[t<0])} (\code{absolute} loss with \code{alpha=1/2});
\code{type="square"} for the square loss \code{rho(t)=t^2}; 
\code{type="Huber"} for the Huber loss \code{rho(t)=t^2/2} if 
 \code{|t|<tuning} and \code{rho(t)=tuning*(|t|-tuning/2)} otherwise; and
\code{type="logistic"} for the logistic loss 
\code{rho(t)=2*t + 4*log(1+exp(-t))-4*log(2)}.}

\item{alpha}{The order of the quantile if \code{type="quantile"}. By default
taken to be \code{alpha=1/2}, which gives the absolute loss 
(\code{type="absolute"}).}

\item{tuning}{tuning parameter, a non-negative real number, affects only
the Huber loss (by default \code{tuning = 1.345}.}
}
\value{
A numerical value.
}
\description{
Evaluates the location and regression objective function given the imput parameters. Used to assess accuracy of the models.
}
\examples{
n = 50      # sample size
p = 10      # dimension of predictors
Z = matrix(rnorm(n*p),ncol=p) # design matrix \eqn{m_{\star}} x p 
Y = Z[,1]   # response vector
lambda = 1  # tuning parameter for penalization
H = diag(p) # penalty matrix

res_C = QuantileQp(Z, Y, lambda, H, vrs="C")
res_R = QuantileQp(Z, Y, lambda, H, vrs="R")
# Check the maximum absolute difference between the results
max(abs(res_C$theta_hat-res_R$theta_hat))
# Visualize the difference between the results
plot(res_C$theta_hat ~ res_R$theta_hat)

# Compare the output with function IRLS
res_IRLS = IRLS(Z, Y, lambda, H, type="quantile")
max(abs(res_C$theta_hat-res_IRLS$theta_hat))

evaluate_objective(res_C$theta_hat, Y, Z, lambda*H, type="quantile")

}
